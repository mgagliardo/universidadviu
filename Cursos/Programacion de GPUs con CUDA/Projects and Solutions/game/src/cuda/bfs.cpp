#include "bfs.hpp"
#include "bfskernels.hu"

#include <utility>
#include <list>
#include <queue>
#include <limits>

#include <sys/time.h>

const int GAME_LENGTH = 10;

BFS::BFS()
{
#ifdef CUDACC
  cout << "Running CPU/GPU BFS Hybrid." << endl;
#else
  cout << "Running CPU BFS." << endl;
#endif
}

BFS::~BFS()
{
    releaseMemory();
}


size_t BFS::generateCPU(treenode * const baseStates, size_t numBaseStates, 
                        treenode *nextStates, bool player1) {

  // Do CPU generation
  //if (player1) cout << "looking at player1's moves." << endl;
  //else         cout << "looking at player2's moves." << endl;

  // Loop through all input boards
  size_t generatedBoards = 0;
  for (size_t baseIndex = 0; baseIndex < numBaseStates; ++baseIndex)
  {
      treenode& baseNode = baseStates[baseIndex];
      const CheckersBoard& baseBoard = baseNode.board;

      // The different kinds of moves that can result from this board.
      // at the end, simpleMoveResults should be empty if takeoverChainResults
      // has at least one move in it. This reflects having to take available
      // capture moves.
      vector<treenode> simpleMoveResults, takeoverChainResults;

      // Loop through all spaces in the board
      for (size_t boardIndex = 0; boardIndex < 64; ++boardIndex)
      {
          //cout << "BFS::generate(): <baseIndex,boardIndex>=<" << baseIndex << "," << boardIndex << ">" << endl;
          if (!baseBoard.isOccupiableSpace(boardIndex)) continue;

          if ( (player1 && (baseBoard.p1Piece(boardIndex) == true)) || (!player1 && (baseBoard.p2Piece(boardIndex) == true)) )
          {
            // Get the next boards from this particular board and piece
            // if there are possible results of a capture move, don't even consider simple moves.
            vector<CheckersBoard> pieceSimpleMoveResults, pieceTakeoverChainResults;
            assert(pieceSimpleMoveResults.empty());
            assert(pieceTakeoverChainResults.empty());
            if (takeoverChainResults.empty()) {
              pieceSimpleMoveResults = simpleMoveBoards(baseBoard, boardIndex, player1);
            }
            pieceTakeoverChainResults = takeoverChainBoards(baseBoard, boardIndex, player1);

            // Move all nextBoards generated by moving this piece into the set of boards for the
            // whole input board
            for (size_t i = 0; i < pieceSimpleMoveResults.size(); ++i) {
              treenode tn = { pieceSimpleMoveResults[i], baseIndex, 0, 0 };
              simpleMoveResults.push_back(tn);
            }

            for (size_t i = 0; i < pieceTakeoverChainResults.size(); ++i) {
              treenode tn = { pieceTakeoverChainResults[i], baseIndex, 0, 0 };
              takeoverChainResults.push_back(tn);
            }

          }

      }
      // Done looping through all pieces in this board. If there are any takeover moves, ignore all simple moves.
      if (takeoverChainResults.empty()) {
        for (size_t i = 0; i < simpleMoveResults.size(); ++i) {
          nextStates[generatedBoards++] = simpleMoveResults[i];
        }
        baseNode.hasChildren |= (simpleMoveResults.size() > 0);
      }
      for (size_t i = 0; i < takeoverChainResults.size(); ++i) {
        nextStates[generatedBoards++] = takeoverChainResults[i];
      }
      baseNode.hasChildren |= (takeoverChainResults.size() > 0);
  }
  //cout << "reporting " << generatedBoards << " boards generated" << endl;
  return generatedBoards;

}


size_t BFS::generate(treenode *baseStates, size_t numBaseStates,
        treenode *nextStates, size_t numNextStates, bool player1)
{
#ifdef CUDACC
  if (false) { //used for performance comparison
    printf("Generate called on %ld baseStates\n", numBaseStates);

    timeval tim;
    gettimeofday(&tim, NULL);
    double start = tim.tv_sec + (tim.tv_usec/1000000.0);
    generateWrapper(baseStates, numBaseStates, nextStates, numNextStates, player1);
    gettimeofday(&tim, NULL);
    double end = tim.tv_sec + (tim.tv_usec/1000000.0);
    printf("GPU seconds elapsed: %.6f\n", end-start);
  

    gettimeofday(&tim, NULL);
    start = tim.tv_sec + (tim.tv_usec/1000000.0);
    size_t numGeneratedBoards = generateCPU(baseStates, numBaseStates, nextStates, player1);
    gettimeofday(&tim, NULL);
    end = tim.tv_sec + (tim.tv_usec/1000000.0);
    printf("CPU seconds elapsed: %.6f\n", end-start);

    return numGeneratedBoards;
  }


  if (numBaseStates > TREELEVEL_CPU_LIMIT) {
    return generateWrapper(baseStates, numBaseStates, nextStates, numNextStates, player1);
  }
  else {
#endif
    size_t numGeneratedBoards = generateCPU(baseStates, numBaseStates, nextStates, player1);
    return numGeneratedBoards;
#ifdef CUDACC
  }
#endif
}



list<unsigned int> BFS::possibleSimpleMoves(const CheckersBoard& inBoard, unsigned int pieceIndex, bool player1) const
{
    // row / column
    pair<unsigned int, unsigned int>rc(pieceIndex / 8, pieceIndex % 8);

    // Generate possible no-jump row/col pairings.
    const pair<size_t, size_t> possibleTargets[] =
    { pair<unsigned int, unsigned int>(rc.first + 1, rc.second + 1),
        pair<unsigned int, unsigned int>(rc.first + 1, rc.second - 1),
        pair<unsigned int, unsigned int>(rc.first - 1, rc.second + 1),
        pair<unsigned int, unsigned int>(rc.first - 1, rc.second - 1)  };

    list<unsigned int> validMoves;
    // Build the initial validMoves set out of the possible moves that are inside the board
    for (int i = 0; i < 4; ++i) {
        if ( (possibleTargets[i].first < 8) && (possibleTargets[i].second < 8) )
        {
            unsigned int index = possibleTargets[i].first * 8 + possibleTargets[i].second;
            assert(inBoard.isOccupiableSpace(index));
            validMoves.push_front(index);
        }
    }

    vector<list<unsigned int>::iterator> toErase;
    // Remove moves that the piece cannot take if it is not a king
    for (list<unsigned int>::iterator i = validMoves.begin(); i != validMoves.end(); ++i) {
        if (player1 && inBoard.p1Man(pieceIndex)) {
            if (*i < pieceIndex) toErase.push_back(i); // p1 men can't move backwards
        }
        else if (!player1 && inBoard.p2Man(pieceIndex)) {
            if (*i > pieceIndex) toErase.push_back(i); // p2 men can't move forwards
        }
    }
    for (size_t i = 0; i < toErase.size(); ++i) validMoves.erase(toErase[i]);

    // Check if the move destinations are empty and erase any that are not.
    // Erased iterators are invalid, so  can't erase as we iterate over.
    toErase.clear();
    for (list<unsigned int>::iterator i = validMoves.begin(); i != validMoves.end(); ++i)
    {
        if (inBoard.piece(*i)) toErase.push_back(i);
    }
    for (unsigned int i = 0; i < toErase.size(); ++i) validMoves.erase(toErase[i]);

    return validMoves;
}

list<unsigned int> BFS::possibleTakeoverMoves(const CheckersBoard& inBoard, unsigned int pieceIndex, bool player1) const
{
    list<unsigned int> validMoves; 

    // Input row and column
    pair<unsigned int, unsigned int>rc(pieceIndex / 8, pieceIndex % 8);

    // Generate possible one-jump row/col pairings.
    const pair<unsigned int, unsigned int> possibleTargets[] = 
    { pair<unsigned int, unsigned int>(rc.first + 2, rc.second + 2),
        pair<unsigned int, unsigned int>(rc.first + 2, rc.second - 2),
        pair<unsigned int, unsigned int>(rc.first - 2, rc.second + 2),
        pair<unsigned int, unsigned int>(rc.first - 2, rc.second - 2)  };

    // Build the initial validMoves set out of the possible moves that are inside the board
    for (unsigned i = 0; i < 4; ++i) {
        if ( (possibleTargets[i].first < 8) && (possibleTargets[i].second < 8) )
        {
            unsigned int index = possibleTargets[i].first * 8 + possibleTargets[i].second;
            assert(inBoard.isOccupiableSpace(index));
            validMoves.push_front(index);
        }
    }

    // Erase "backward" moves if the piece is not a king.
    vector<list<unsigned int>::iterator> toErase;
    for (list<unsigned int>::iterator i = validMoves.begin(); i != validMoves.end(); ++i) {
        if (player1 && inBoard.p1Man(pieceIndex)) {
            if (*i < pieceIndex) toErase.push_back(i); // p1 men can't move backwards
        }
        else if (!player1 && inBoard.p2Man(pieceIndex)) {
            if (*i > pieceIndex) toErase.push_back(i); // p2 men can't move forwards
        }
    }
    for (size_t i = 0; i < toErase.size(); ++i) validMoves.erase(toErase[i]);

    // Check if the move destinations are empty and erase any that are not.
    toErase.clear();
    for (list<unsigned int>::iterator i = validMoves.begin(); i != validMoves.end(); ++i)
    {
        if (inBoard.piece(*i)) toErase.push_back(i);
    } 
    for (size_t i = 0; i < toErase.size(); ++i) validMoves.erase(toErase[i]);

    // Check if the jump will pass over an opposing piece. Remove any targets
    // that do not
    toErase.clear();
    for (list<unsigned int>::iterator i = validMoves.begin(); i != validMoves.end(); ++i)
    {
        // since we know all targets are valid now, we can average the target with the
        // starting position to get the capture index.
        unsigned int captureIndex = (*i + pieceIndex) / 2;
        if      ( player1 && !inBoard.p2Piece(captureIndex)) toErase.push_back(i);
        else if (!player1 && !inBoard.p1Piece(captureIndex)) toErase.push_back(i);
    }
    for (size_t i = 0; i < toErase.size(); ++i) validMoves.erase(toErase[i]);

    return validMoves;
}

vector<CheckersBoard> BFS::simpleMoveBoards(const CheckersBoard& inBoard, unsigned int pieceIndex, bool player1) const
{
    vector<CheckersBoard> childBoards;
    list<unsigned int> simpleMoves = possibleSimpleMoves(inBoard, pieceIndex, player1);

    // Create all the child boards based on the possible moves.
    for (list<unsigned int>::iterator i = simpleMoves.begin(); i != simpleMoves.end(); ++i)
    {
        CheckersBoard newBoard = inBoard;
        newBoard.move(*i, pieceIndex);
        childBoards.push_back(newBoard);
    }

    return childBoards;
}

vector<CheckersBoard> BFS::takeoverChainBoards(const CheckersBoard& inBoard, unsigned int pieceIndex, bool player1) const
{
    vector<CheckersBoard> childBoards;

    // create a datatype that combines a board with the index of the piece that we are trying to move.
    // for example, if this were passed as an input to this function, it would be
    // IndexBoardPair IBP.first = inboard
    // IndexBoardPair IBP.second = pieceIndex
    typedef pair<CheckersBoard, unsigned int> IndexBoardPair;
    queue<IndexBoardPair> chainBoards;

    // Start the queue of chain moves to analyze with the possible takeover moves from the first board.
    list<unsigned int> takeoverMoves = possibleTakeoverMoves(inBoard, pieceIndex, player1);
    for (list<unsigned int>::iterator i = takeoverMoves.begin(); i != takeoverMoves.end(); ++i) {
        CheckersBoard newBoard(inBoard);
        unsigned int captureIndex = (pieceIndex + *i) / 2;
        newBoard.captureMove(*i, captureIndex, pieceIndex);
        IndexBoardPair newPair(newBoard, *i);
        // If the move caused a king, then the chain has to stop. We'll put the new board in childBoards instead
        // of chainBoards.
        if (inBoard.moveWillKing(*i, pieceIndex)) {
          childBoards.push_back(newBoard);
        }
        else {
          chainBoards.push(newPair);
        }
    } 

    // As long as there are boards in a chain of takeovers left to analyze:
    while (!chainBoards.empty()) {
        // Get a board to analyze.
        IndexBoardPair testPair = chainBoards.front();
        chainBoards.pop(); 

        // Generate all the possible takeover moves.
        takeoverMoves = possibleTakeoverMoves(testPair.first, testPair.second, player1);

        // If there aren't any following takeover moves, this one finishes up a chain of captures and should be returned
        if (takeoverMoves.size() == 0) childBoards.push_back(testPair.first);
        // Otherwise, add all of its children to the worklist by following the legal capture moves.
        else {
            for (list<unsigned int>::iterator i = takeoverMoves.begin(); i != takeoverMoves.end(); ++i) {
                CheckersBoard newBoard = testPair.first;
                unsigned int captureIndex = (testPair.second + *i) / 2;
                newBoard.captureMove(*i, captureIndex, testPair.second);
                IndexBoardPair newPair(newBoard, *i);
                // Iff the move causes a king, the chain must stop. Place the board in childBoards instead
                // of adding it to the worklist.
                if (testPair.first.moveWillKing(*i, pieceIndex)) {
                  childBoards.push_back(newBoard);
                }
                else {
                  chainBoards.push(newPair);
                }
            }
        }
    }

    return childBoards;
}

void BFS::buildLevels(const CheckersBoard start, const size_t depth, const bool player1, int startingPly)
{
    // Clear the internal data structures to prepare for the next search.
    releaseMemory();

    // Check inputs for sensibility
    assert(depth > 0);
    assert(startingPly >= 0);

    startingPly_ = startingPly;

    // Set up vector describing which player is acting at each tree level
    for (size_t i = 1; i < depth; ++i) {
        (i % 2) ? player1Moving_.push_back(player1) : player1Moving_.push_back(!player1);
    }

    // Create a persistent copy of level 0
    treenode *level0 = new treenode;
    level0->board = start;
    level0->parentIndex = 0;
    level0->score = 0;
    level0->hasChildren = false;
    treeLevels_.push_back(level0);
    treeLevelSizes_.push_back(1);

    // Loop through all other levels and generate them.
    for (size_t levelnum = 1; levelnum < depth; ++levelnum)
    {
        // Determine the size of the next level in the tree
        size_t estimatedLevelSize;
        estimatedLevelSize = calcNextLevelSize(treeLevels_[levelnum-1], treeLevelSizes_[levelnum-1], player1Moving_[levelnum-1]);
        //cout << "BFS::search(): estimated dim of levelnum " << levelnum << " = " << estimatedLevelSize << endl;

        // Allocate space for the tree level and store its location and size
        treenode *nextLevel = (treenode*) malloc(estimatedLevelSize * sizeof(treenode));
        if (!nextLevel) {
            cerr << "Died while tring to allocate " << estimatedLevelSize * sizeof(treenode) / 1024 / 1024 << "M" << endl;
            exit(1);
        }
        //cout << "BFS::search(): allocated space~= " << estimatedLevelSize * sizeof(treenode) / 1024 / 1024 << "M" << endl;

        // Generate the actual nodes in the next level. The GPU version needs estimatedLevelSize so it knows how much memory to allocate.
        size_t levelSize = generate(treeLevels_[levelnum-1], treeLevelSizes_[levelnum-1], nextLevel, estimatedLevelSize, player1Moving_[levelnum-1]);
        //cout << "BFS::search(): generated level, actual dim of levelnum " << levelnum << "=" << levelSize << endl;
#if defined(DEBUG)
        assert(levelSize <= estimatedLevelSize);
#endif
        // Shrink the memory to the actual size of the next level
        nextLevel = (treenode*) realloc(nextLevel, levelSize * sizeof(treenode));
        //cout << "BFS::search(): reallocated space~=" << levelSize * sizeof(treenode) / 1024 / 1024 << "M" << endl;

        // Keep the location of the level and its actual size
        treeLevels_.push_back(nextLevel);
        treeLevelSizes_.push_back(levelSize);
    }
}
void BFS::getLastLevel(treenode** lastLevel, int& lastLevelSize, bool& player1Up)
{
    *lastLevel = treeLevels_.back();
    player1Up = player1Moving_.back();
    lastLevelSize = treeLevelSizes_.back();
}

CheckersBoard BFS::propogateScoresPickWinner(const bool player1)
{
    // Propogate the scores back up through the tree
    for (size_t levelnum = treeLevels_.size() - 1; levelnum > 0; --levelnum)
    {
        bool pov = player1Moving_[levelnum - 1];
        int levelPlyNum = startingPly_ + levelnum - 1;

        //if (pov) cout << "BFS::search(): player1 choosing best  scores from " << levelnum << " -> " << levelnum - 1 << endl;
        //else     cout << "BFS::search(): player2 choosing worst scores from " << levelnum << " -> " << levelnum - 1 << endl;

        propogateScores(treeLevels_[levelnum-1], treeLevels_[levelnum], 
                treeLevelSizes_[levelnum-1], treeLevelSizes_[levelnum], pov, levelPlyNum);

    }

    // Chose the best maximizing or minimizing move

    // FIXME: get a list of the boards that tie for the best score
    // All of these boards have the same score
    vector<CheckersBoard> bestBoards;
    assert(treeLevelSizes_[1] > 0);
    bestBoards.push_back(treeLevels_[1][0].board);
    float bestScore = treeLevels_[1][0].score;

    for (size_t i = 1; i < treeLevelSizes_[1]; ++i){
        if (player1) { // maximizing score for player 1
            if (treeLevels_[1][i].score > bestScore) {
                bestScore = treeLevels_[1][i].score;
                bestBoards.clear();
                bestBoards.push_back(treeLevels_[1][i].board);
            }
            // If it's a tie, add it to the list
            else if (treeLevels_[1][i].score == bestScore) {
                bestBoards.push_back(treeLevels_[1][i].board);
            }
        }
        else { // minimizing score for player 2
            if (treeLevels_[1][i].score < bestScore) {
                bestScore = treeLevels_[1][i].score;
                bestBoards.clear();
                bestBoards.push_back(treeLevels_[1][i].board);
            }
            else if (treeLevels_[1][i].score == bestScore) {
                bestBoards.push_back(treeLevels_[1][i].board);
            }
        }
    }

    size_t randomIndex = rand() % bestBoards.size();
    //return bestBoards[randomIndex];
    return bestBoards.front(); //debug consistency
}


CheckersBoard BFS::search(const CheckersBoard start, const size_t depth, const bool player1, int startingPly)
{
    if (1 == depth) return start;
    buildLevels(start, depth, player1,startingPly);

    // Evaluate leaves
    evaluateLeaves();
    //cout << "BFS::search(): evaluated last tree level: " << treeLevelSizes_.back() << " nodes." << endl;

    return propogateScoresPickWinner(player1);
}

void BFS::releaseMemory()
{
    // Clean up the tree, if it exists.
    if (treeLevels_.size() > 0) {
        delete treeLevels_[0];
    }

    for (size_t i = 1; i < treeLevels_.size() ; ++i) {
        free(treeLevels_[i]);
    }

    // Force reallocation of vectors to release their memory.
    vector<treenode*>().swap(treeLevels_);
    vector<size_t>().swap(treeLevelSizes_);
    vector<bool>().swap(player1Moving_);
}



// A game is over if a player cannot make a move, or 80 plies have been done.
bool BFS::isTerminal(const CheckersBoard& c, bool player1, int plies) const
{
    if (plies > GAME_LENGTH - 1) {
        cout << "Game over due to length." << endl;
        return true;
    }

    // Otherwise, check if the player in question can make any moves.
    if (!canMove(c, player1))
    {
        if (player1) cout << "Game over because player1 can't move." << endl;
        else         cout << "Game over because player2 can't move." << endl;
        return true;
    }
    return false;
}



char BFS::winner(const CheckersBoard& c, int plies) const
{
    bool player1CanMove = canMove(c, true);
    bool player2CanMove = canMove(c, false);

    // No one can move - draw
    if (!player1CanMove && !player2CanMove) return 0;

    // both players can move:
    if ( player1CanMove &&  player2CanMove) {
        if (plies > GAME_LENGTH - 1) return  0; // draw if game is too long
        else                         return -1; // game isn't over
    }

    if (!player1CanMove) return 2;
    else                 return 1;

    assert(0 && "How did we get here?");
}


size_t BFS::calcNextLevelSize(treenode *baseStates, size_t numBaseStates, bool player1)
{
    // Produces about 2x the actual result size. 
    return numBaseStates * 12 * 19 / 15;
}



void BFS::evaluateLeaves()
{
    size_t numNodes = treeLevelSizes_.back();
    //bool leavesGeneratedByPlayer1 = player1Moving_.back();
    //if (leavesGeneratedByPlayer1) cout << "player1 moved to generate leaves." << endl;
    //else                          cout << "player2 moved to generate leaves." << endl;

#ifdef CUDACC
  if (false) { //used for performance comparison
    printf("evaluateLeaves called on %ld baseStates\n", numNodes);

    timeval tim;
    gettimeofday(&tim, NULL);
    double start = tim.tv_sec + (tim.tv_usec/1000000.0);
    evaluateLeavesWrapper(treeLevels_.back(), treeLevelSizes_.back());
    gettimeofday(&tim, NULL);
    double end = tim.tv_sec + (tim.tv_usec/1000000.0);
    printf("GPU seconds elapsed: %.6f\n", end-start);


    gettimeofday(&tim, NULL);
    start = tim.tv_sec + (tim.tv_usec/1000000.0);
    
    // CPU leaf eval
    int leafPly = startingPly_ + treeLevelSizes_.size() - 1;
    for (size_t i = 0; i < treeLevelSizes_.back(); ++i)
    {
      treenode& curNode = treeLevels_.back()[i];
      assert(!curNode.hasChildren);
      curNode.score = utility(curNode.board, leafPly);
    }
    // end CPU leaf eval

    gettimeofday(&tim, NULL);
    end = tim.tv_sec + (tim.tv_usec/1000000.0);
    printf("CPU seconds elapsed: %.6f\n", end-start);

    return;
  }
#endif



#ifdef CUDACC
    if(numNodes > TREELEVEL_CPU_LIMIT_TEST)
    {
        // Launch kernel.
        evaluateLeavesWrapper(treeLevels_.back(), treeLevelSizes_.back());
    }
    else
    {
#endif
        int leafPly = startingPly_ + treeLevelSizes_.size() - 1;
        for (size_t i = 0; i < treeLevelSizes_.back(); ++i)
        {
            treenode& curNode = treeLevels_.back()[i];
            assert(!curNode.hasChildren);
            curNode.score = utility(curNode.board, leafPly);
        }
#ifdef CUDACC
    }
#endif
}



int BFS::utility(const CheckersBoard& c, int plyNum) const
{
  // Try getting the winner:
  char win = winner(c, plyNum);
  // Max utility if p1 wins
  if ( win == 1 ) return      std::numeric_limits<int>::max();
  // Min utility if p2 wins
  if ( win == 2 ) return -1 * std::numeric_limits<int>::max();
  // Intermediate utility if it's a draw
  if ( win == 0 ) return 0;

  // max value here is if every man is a king = 12*15 = 180, and the other 
  // player has no pieces = 0
  size_t p1PieceVal = c.p1WeightedMen() + c.p1NumKings() * 15;
  size_t p2PieceVal = c.p2WeightedMen() + c.p2NumKings() * 15;
  const float scoreMultiplier = int(std::numeric_limits<int>::max()) / int(180);
  if (p1PieceVal > p2PieceVal) {
      return int((float(p1PieceVal) / float(p2PieceVal)) * scoreMultiplier);
  }
  else if (p1PieceVal < p2PieceVal) {
      return  int((-1.0f * float(p1PieceVal) / float(p2PieceVal)) * scoreMultiplier);
  }
  else return 0; 
}



void BFS::propogateScores(treenode *level, treenode *childLevel, size_t levelSize, size_t childLevelSize, bool player1, int levelPlyNum)
{
    CheckersBoard chosenBoard;
    size_t numNodes = childLevelSize; //FIXME

#ifdef CUDACC
    if(numNodes > TREELEVEL_CPU_LIMIT_TEST)
    {
        // Launch kernel.
        scoreCascadeWrapper(childLevel, level, childLevelSize, levelSize, player1);
    }
    else
    {
#endif
    // First pass: evaluate terminal nodes in level, and assign max or min possible score
    // depending on who is chosing.
    //cout << "input level size to propogate to is " << levelSize << endl;
    for (size_t i = 0; i < levelSize; ++i) {
        if (!level[i].hasChildren) level[i].score = utility(level[i].board, levelPlyNum);
        else if (player1) { // player 1 wants the most maximum score, so start with -inf
            level[i].score = (int)(-1.0 * numeric_limits<float>::infinity());
        }
        else { // player 2 wants the most minimum score, so start with infinity
            level[i].score = (int)numeric_limits<float>::infinity();
        }
    } 
        // Second pass: send scores up from children
        for (size_t i = 0; i < childLevelSize; ++i){
            const treenode& childNode = childLevel[i];
            if (player1) { // max score
                if (childNode.score > level[childNode.parentIndex].score) {
                    level[childNode.parentIndex].score = childNode.score;
                }
            }
            else {        // min score
                if (childNode.score < level[childNode.parentIndex].score) {
                    level[childNode.parentIndex].score = childNode.score;
                }
            }
        }
#ifdef CUDACC
    }
#endif

    // debug stuff:
    CheckersBoard bestChild;
    float bestScore = player1 ? -1.0f * numeric_limits<float>::infinity() : numeric_limits<float>::infinity();
    for (size_t i = 0; i < childLevelSize; ++i) {
        if (player1) {
            if (childLevel[i].score > bestScore) {
                bestChild = childLevel[i].board;
                bestScore = childLevel[i].score;
            }
        }
        else {
            if (childLevel[i].score < bestScore) {
                //cout << "new best child for p2:" << endl;
                //childLevel[i].board.dump(cout);
                //cout << "with score " << childLevel[i].score << endl;
                bestChild = childLevel[i].board;
                bestScore = childLevel[i].score;
            }
        }
    }
    //cout << "Propogate scores thinks this is best child board: " << endl;
    //bestChild.dump(cout);
    //cout << "with score " << bestScore << endl;
}

float BFS::getMillis() const
{
  return (float(clock()) / CLOCKS_PER_SEC)*1000;
}

bool BFS::canMove(const CheckersBoard& c, const bool player1) const
{
    // Loop through all board indexes and check if the player can move.
    for (uint8_t i = 0; i < 64; ++i) {
        if (!c.isOccupiableSpace(i)) continue;
        // If there is a piece at that index
        if ( (player1 && c.p1Piece(i)) || (!player1 && c.p2Piece(i)) ) {
            vector<CheckersBoard> simpleMoveResults = simpleMoveBoards(c, i, player1);
            vector<CheckersBoard> takeoverChainResults = takeoverChainBoards(c, i, player1);
            if (!simpleMoveResults.empty() || !takeoverChainResults.empty()) return true;
        }
    }
    return false;
}
